// 1. Require in the module to test
//
//    Also require in any other dependencies needed to run your tests
const Arithmetic = require("../arithmetic");

// 2. Setup a block of tests to run under a descriptive heading.
//
//    Test suites and their output can be quite long and hard to read. Organizng
//    in descriptive block makes it easier to read the output
//
//    describe() is just a function that takes a string and a function. The string
//    acts as a label for the block of tests and the function is the set of tests to run
describe("Arithmetic", () => {
  // 3. Setup any desired sub blocks using nested describe() functions
  //
  describe("Initialization", () => {
    // 4. write your tests
    //
    //    A test should be limited to a limited aspect of the test subject. This makes it
    //    easier to determine if the test passess or fails. It also identifies and tests
    //    where things could possibly go wrong. For example, in order to do arithmetic,
    //    an Arithmetic object must first be created. Notice how this test just checks to see if an
    //    Arithmetic object is created,not whether the Arithmetic object actually does math correctly.
    //
    //    it() is a function like describe(). It takes a string that labels the test and a function to run
    //    the test. The label is written as a behavior, i.e., did the test subject behave the way we
    //    expected. It is not concerned with implmentation details, just with a resultant behavior.
    //
    //    FYI: it() is an alias for test() - they are the same thing
    it("should return an object containing a 'number' property when called with the 'new' keyword", () => {
      const obj = new Arithmetic();

      expect("number" in obj).toEqual(true);
    });

    it("should set 'number' when created", () => {
      // Tests are written in three stages

      // Stage 1: Arrange
      // Here we arrange the preconditions of the test and sometimes an expected result
      // that we can compare against the actual result produced by the test subject
      const num = 108;

      // Stage 2: Act
      // Perform some action with the test subject to generate a result
      const obj = new Arithmetic(num);

      // Stage 3: Asssert
      // Compare the result against our expectation
      //
      // Here we assert an expectation that the resultant obj.number === our expected number
      // If it doesn't behave as expected, the expect() function throws an error that is caught
      // and reported later in our test results
      expect(obj.number).toEqual(num);
    });

    it("should default 'number' to 0", () => {
      // Arrange and Act happen on the same line here
      const obj = new Arithmetic();

      expect(obj.number).toEqual(0);
    });
  });

  describe("plus", () => {
    it("should return a new 'Arithmetic' object", () => {
      const obj = new Arithmetic(3).plus(3);

      expect(obj instanceof Arithmetic).toEqual(true);
    });

    it("should return a new 'Arithmetic' object that has an updated 'number' value", () => {
      const num = 8;
      const added = 7;
      const sum = num + added;

      const { number } = new Arithmetic(num).plus(added);

      expect(number).toEqual(sum);
    });
  });

  describe("minus", () => {
    it("should return a new 'Arithmetic' object", () => {
      const obj = new Arithmetic(9).minus(4);

      expect(obj instanceof Arithmetic).toEqual(true);
    });

    it("should return a new 'Arithmetic' object that has an updated 'number' value", () => {
      const num = 10;
      const subtracted = 17;
      const difference = num - subtracted;

      const { number } = new Arithmetic(num).minus(subtracted);

      expect(number).toEqual(difference);
    });
  });

  describe("value", () => {
    it("should return the 'Arithmetic' object's 'number' value", () => {
      const num = 10;
      const obj = new Arithmetic(num);

      const result = obj.value();

      expect(result).toEqual(num);
    });
  });
});
